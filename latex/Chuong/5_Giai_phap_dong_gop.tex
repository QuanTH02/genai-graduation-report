\documentclass[../DoAn.tex]{subfiles}
\begin{document}

Trong chương này, em sẽ trình bày các vấn đề mà em đã gặp phải và những giải pháp cụ thể mà em đã áp dụng để giải quyết chúng. Đồng thời, em cũng sẽ trình bày các đóng góp đáng chú ý mà em đánh giá cao trong quá trình thực hiện đồ án tốt nghiệp.

\section{Thiếu dữ liệu phim ảnh}
Vấn đề này phát sinh khi em cần một lượng lớn dữ liệu về các bộ phim để xây dựng hệ thống gợi ý. Để giải quyết vấn đề này, em đã tiến hành tìm kiếm và lựa chọn các trang web có uy tín để lấy dữ liệu. Việc này bao gồm việc phân tích cú pháp của các trang web, xác định cách truy cập và lấy dữ liệu một cách tự động.

\section{Thiết kế database khó khăn với quá nhiều trường}

Khi thiết kế cơ sở dữ liệu, em gặp khó khăn khi phải xử lý một lượng lớn các trường thông tin về phim và người dùng. Để giải quyết vấn đề này, em đã áp dụng nguyên tắc chuẩn hóa cơ sở dữ liệu và chia nhỏ các trường thông tin có liên quan thành các bảng dữ liệu con. Sau đó, em xác định mối liên hệ giữa các bảng và kết hợp chúng lại với nhau để tạo ra cấu trúc cơ sở dữ liệu hợp lý và hiệu quả.

\section{Trang web có dữ liệu update liên tục theo ngày}

Một trong số các trang web mà em lấy dữ liệu đó là IMDb, ở trang web này, có rất nhiều trường thông tin, nhưng việc khó khăn để lấy dữ liệu nhất đối với em chính là lấy link ảnh và link trailer. Ở trang web này, cứ 1 ngày thì các link ảnh và trailer sẽ được làm mới 1 lần, cho nên qua ngày khác thì link cũ sẽ bị hỏng và không truy cập được nữa. Em đã nghĩ ra 2 phương án để giải quyết đó là: Tải toàn bộ ảnh và trailer xuống hoặc tìm cách để hệ thống tự update data.

Ở cách giải quyết là tải toàn bộ ảnh và trailer xuống thì em đã loại bỏ ngay sau khi quyết định số bộ phim để demo hệ thống. Với 1000 bộ phim thì sẽ có tổng cộng hơn 50000 ảnh và 1000 video demo, nếu tải về thì rất nặng máy và không tối ưu. Vì thế, em đã nghiên cứu và tìm ra cách để hệ thống tự update data, đó chính là dùng github action.

\subsection{Github Action}
\textbf{Giới thiệu:}

Github Actions là một dịch vụ được cung cấp bởi GitHub để tự động hóa các quy trình phát triển phần mềm trong các repository. Bằng cách sử dụng các "actions" (hành động), em có thể thiết lập các luồng làm việc tự động, từ việc kiểm tra mã nguồn, triển khai ứng dụng, đến tự động hóa các tác vụ như cập nhật dữ liệu trong hệ thống.

\textbf{Triển khai:}

Đầu tiên, em viết 1 file crawlJson.py, mục đích để crawl toàn bộ dữ liệu mới từ trang IMDb về và lưu vào file update.sql, khi có file update.sql rồi thì chỉ việc cập nhật vào local của mình là sẽ có dữ liệu mới.

Để hệ thống có thể tự động update được, sẽ có những bước như sau:

\begin{enumerate}
    \item Tạo PAT (Personal Access Token) Github

    Personal Access Token (PAT) trên GitHub được sử dụng để cung cấp quyền truy cập cho các ứng dụng hoặc dịch vụ bên thứ ba vào tài khoản GitHub, mà không cần phải sử dụng mật khẩu. Ở trong hệ thống này, dịch vụ bên thứ 3 chính là bot tự động.

    \begin{figure}[H]
        \centering
        \includegraphics[width=1\linewidth]{Hinhve/gh_at_1.png}
        \caption{Tạo PAT Github}
        \label{fig:gh_at_1}
    \end{figure}
    
    \item Tạo Secrets Repository

    Mục đích của việc tạo Secrets trên GitHub là để bảo vệ và quản lý các thông tin nhạy cảm như mã token, mật khẩu, khóa API, và các thông tin quan trọng khác trong quá trình phát triển và triển khai phần mềm. Việc sử dụng Secrets giúp đảm bảo rằng các thông tin này không được lộ ra ngoài công cộng, chỉ có thể được truy cập và sử dụng bởi các công cụ tự động hóa như GitHub Actions hoặc các ứng dụng khác thông qua API được cho phép.

    \begin{figure}[H]
        \centering
        \includegraphics[width=1\linewidth]{Hinhve/gh_at_2.png}
        \caption{Tạo Secrets Repository}
        \label{fig:gh_at_2}
    \end{figure}
    
    \item Viết file update.yml

    Bước cuối cùng, em sẽ viết file update.yml để Github Action có thể chạy tự động
\end{enumerate}

\textbf{Kết quả:}

Cứ 00h00 hằng ngày, hệ thống sẽ tự động crawl dữ liệu mới, lưu vào file update.sql và push code lên github trong khoảng 1 tiếng.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Hinhve/gh_at_3.png}
    \caption{Hệ thống tự động crawl dữ liệu}
    \label{fig:gh_at_3}
\end{figure}

Sau khi hệ thống cho ra file update.sql rồi, chỉ cần pull code về máy chủ, chạy file Crawl/autoUpdate/update.py thì sẽ có dữ liệu mới ngay lập tức.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Hinhve/gh_at_4.png}
    \caption{Cập nhật dữ liệu mới thành công}
    \label{fig:gh_at_4}
\end{figure}

\section{Lựa chọn thuật toán gợi ý phù hợp}

Việc lựa chọn thuật toán gợi ý phù hợp là một thách thức quan trọng trong quá trình phát triển hệ thống gợi ý phim. Em đã tham khảo các bài báo và tài liệu trên mạng, thực hiện thử nghiệm và đánh giá các thuật toán khác nhau để tìm ra thuật toán phù hợp nhất với yêu cầu của dự án. Cụ thể chính là 2 thuật toán Content-based và Collaborative.

\subsection{Content-based}
\textbf{Giới thiệu:}

Trong hệ thống content-based này, dựa trên nội dung của mỗi movie, em xây dựng một bộ hộ sơ cho mỗi movie. Hồ sơ này được biểu diễn dưới dạng toán học là một feature vector. Features của một bộ phim trong hệ thống gợi ý em xây dựng này là:

\begin{itemize}
    \item Movie name: Tên của bộ phim đó
    \item Genres: Thể loại của bộ phim đó
    \item Describe: Mô tả sơ lược về nội dung của bộ phim đó
    \item Cast: Diễn viên của bộ phim đó
    \item Director: Đạo diễn của bộ phim đó
\end{itemize}

\textbf{Phân tích, giải pháp:}

Content-based là thuật toán mà khi chọn một item, thì sẽ đưa ra các item tương tự có những đặc điểm cụ thể giống với item đã chọn. Vì thế trong bài toán này em đã chọn cách tính độ tương đồng giữa các bộ phim dựa trên các feature ở trên.

\[
\text{similarity}(A, B) = \cos(\theta) = \frac{A \cdot B}{\|A\| \|B\|}
\]

Trong đó:
\begin{itemize}
  \item \(A\) và \(B\) là hai vector đại diện cho hai phim hoặc hai người dùng.
  \item \(A \cdot B\) là tích vô hướng của hai vector \(A\) và \(B\).
  \item \(\|A\|\) và \(\|B\|\) lần lượt là độ lớn của vector \(A\) và vector \(B\).
\end{itemize}

\textbf{Kiểm tra tính chính xác:}

Sau khi tính toán được độ tương đồng dựa vào công thức similarity trên, em kiểm tra tính chính xác của thuật toán bằng cách: Tính toán độ tương đồng riêng lẻ của các đặc trưng như movie name, genres, cast, director, describe. Sau đó kiểm tra kết quả cuối cùng với các kết quả riêng biệt xem có chính xác không.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Hinhve/rcm_ct_kq_1.png}
    \caption{Kiểm tra kết quả 1}
    \label{fig:rcm_ct_kq_1}
\end{figure}

Ở hình ảnh \ref{fig:rcm_ct_kq_1} có thể thấy bộ phim được gợi ý gần nhất với bộ phim Guardians of the Galaxy là bộ phim Guardians of the Galaxy Vol. 3. Hai bộ phim này có movie name, describe, cast và director khá tương tự nhau.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Hinhve/rcm_ct_kq_2.png}
    \caption{Kiểm tra kết quả 2}
    \label{fig:rcm_ct_kq_2}
\end{figure}

Ở hình ảnh \ref{fig:rcm_ct_kq_2} có thể thấy bộ phim được gợi ý gần nhất với bộ phim The Hunger Games: Catching Fire là bộ phim The Hunger Games. Hai bộ phim này có movie name, describe, cast và director khá tương tự nhau.


\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Hinhve/rcm_ct_kq_3.png}
    \caption{Kiểm tra kết quả 3}
    \label{fig:rcm_ct_kq_3}
\end{figure}

Ở hình ảnh \ref{fig:rcm_ct_kq_3} có thể thấy bộ phim được gợi ý gần nhất với bộ phim Meg 2: The Trench là bộ phim The Meg. Hai bộ phim này có movie name, describe, cast và director khá tương tự nhau.

Dựa trên các kết quả cho ra ở trên cùng với kiểm tra bằng tính trực quan có thể thấy hệ thống gợi ý phim bằng độ tương đồng được thực hiện khá chính xác.

\subsection{Collaborative}
\textbf{Giới thiệu:}

Ý tưởng cơ bản của Collaborative Filtering là xác định mức độ quan tâm của một user tới một item dựa trên các users khác gần giống với user này. Đối với những users dễ tính, họ có thể đánh giá phim yêu thích là 5 sao, và nếu không thích thì đánh giá có thể thấp hơn một chút, chẳng hạn như 3 sao. Ví dụ, A, B đều thích phim Cảnh sát hình sự, tức đều rate bộ phim này 5 sao. Ta đã biết A cũng thích Người phán xử, vậy nhiều khả năng B cũng thích bộ phim này.

Vấn đề đặt ra là:
\begin{itemize}
    \item Làm thế nào xác định được sự giống nhau giữa hai users?
    \item Khi đã xác định được các users gần giống nhau (similar users) rồi, làm thế nào dự đoán được mức độ quan tâm của một user lên một item?
\end{itemize}

\textbf{Phân tích, giải pháp:}

Công việc quan trọng nhất phải làm trước tiên trong User-user Collaborative Filtering là phải xác định được sự giống nhau (similarity) giữa hai users.

Giả sử chúng ta có các users từ u0 đến u6 và các items từ i0 đến i4 trong đó các ô vuông trong bảng là số rating mà user đã đánh giá cho item đó. Trong một hệ thống có số lượng người dùng và số lượng item rất lớn, rất khó để có dữ liệu người dùng đánh giá nhiều item, một số người dùng thậm chí còn không đánh giá hoặc chỉ đánh giá một số sản phẩm. Những điều này sẽ ảnh hưởng rất lớn để xác định được sự giống nhau giữa hai user. Trong hình \ref{fig:rcm_cl_tb1}, các giá trị bị trống là user chưa đánh giá, khi đó hệ thống sẽ phải đi tìm những giá trị đó.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Hinhve/rcm_cl_tb1.png}
    \caption{Tính giá trị trung bình rating của các user}
    \label{fig:rcm_cl_tb1}
\end{figure}

Để điền giá trị vào các ô trống trên, có thể điền giá trị an toàn là 2.5, vì nó chính là giá trị trung bình của 0 và 5, mức thấp nhất và mức cao nhất. Tuy nhiên, giá trị này vẫn có hạn chế. Đối với những users dễ tính, họ có thể đánh giá phim yêu thích là 5 sao, và nếu không thích thì đánh giá có thể thấp hơn một chút, chẳng hạn như 3 sao. Khi đó việc chọn giá trị 2.5 hơi thấp đối với những user đó. Và tương tự, những user khó tính có thể đánh giá 3 sao cho những bộ phim họ thích và thấp hơn thế nếu họ không thích.

Một giá trị có thể chấp nhận được là trung bình cộng của các ratings mà user tương ứng đã thực hiện Hình \ref{fig:rcm_cl_tb1}. Việc này sẽ tránh được tình trạng bị ảnh hưởng bởi những users quá khó tính hoặc dễ tính. Vì đối với mỗi user, họ lúc nào cũng có những items mà họ ưu tiên hơn những items khác, và được đánh giá cao hơn.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Hinhve/rcm_cl_tb2.png}
    \caption{Tính lại rating theo giá trị trung bình}
    \label{fig:rcm_cl_tb2}
\end{figure}

Việc tính giá trị trung bình này có thể xác định được user đó là dễ tính hay khó tính và có thể xem được item cụ thể user đó thích hay ghét bằng cách lấy giá trị rating item đó trừ đi giá trị trung bình Hình \ref{fig:rcm_cl_tb2}. Khi đó có thể điền các giá trị trống bằng giá trị 0, biểu hiện cho không thích cũng không ghét.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Hinhve/rcm_cl_tb3.png}
    \caption{Tính độ tương đồng giữa các user theo rating mới}
    \label{fig:rcm_cl_tb3}
\end{figure}

Sau đó, ta có thể tính được độ tương đồng giữa các user theo rating mới  Hình \ref{fig:rcm_cl_tb3}. Nhìn qua thì có thể thấy người có độ tương đồng cao nhất và u0 là u1.

Dựa vào độ tương đồng này, ta có thể dự đoán được rating cho item mà user này trước đó chưa đánh giá. Theo công thức như sau:

\begin{equation}
\hat{y}_{i,u} = \frac{\sum_{u_j \in \mathcal{N}(u,i)} \overline{y}_{i,u_j} \text{sim}(u, u_j)}{\sum_{u_j \in \mathcal{N}(u,i)} |\text{sim}(u, u_j)|}
\end{equation}

Trong đó:
\begin{itemize}
  \item $\hat{y}_{i,u}$: Dự đoán giá trị đánh giá của người dùng $u$ cho item $i$.
  \item $\mathcal{N}(u,i)$: Tập hợp các người dùng đã đánh giá item $i$ và có độ tương đồng với người dùng $u$.
  \item $\overline{y}_{i,u_j}$: Giá trị đánh giá mà người dùng $u_j$ đưa ra cho item $i$.
  \item $\text{sim}(u, u_j)$: Độ tương đồng giữa người dùng $u$ và người dùng $u_j$.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Hinhve/rcm_cl_tb4.png}
    \caption{Dự đoán rating cho từng item}
    \label{fig:rcm_cl_tb4}
\end{figure}

Sau khi dự đoán bằng công thức trên, ta có các kết quả dự đoán như Hình \ref{fig:rcm_cl_tb4}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Hinhve/rcm_cl_tb5.png}
    \caption{Kết quả dự đoán rating cuối cùng của hệ thống}
    \label{fig:rcm_cl_tb5}
\end{figure}

Sau khi có kết quả dự đoán dựa trên kết quả rating trung bình, ta cộng giá trị dự đoán đó với rating trung bình của user và được kết quả cuối cùng như Hình \ref{fig:rcm_cl_tb5}.

\textbf{Kiểm tra tính chính xác:}

Sau khi chạy thuật toán, kiểm tra giá trị RMSE với bộ data 100000 lượt rate ta có được kết quả như sau:

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Hinhve/rcm_cl_rmse.png}
    \caption{Giá trị RMSE}
    \label{fig:rcm_cl_rmse}
\end{figure}

Dưới đây là kết quả chạy Collaborative đối với dữ liệu trên:
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Hinhve/rcm_cl_kq_i_to_u.png}
    \caption{Kết quả gợi ý item cho user}
    \label{fig:rcm_cl_kq_i_to_u}
\end{figure}

Có thể thấy kết quả chạy đúng như mong muốn như ở \ref{fig:rcm_cl_tb5}.

Trong chương này, em đã trình bày những vấn đề mà em đã gặp phải và những giải pháp cụ thể mà em đã áp dụng để giải quyết chúng. Những kinh nghiệm này không chỉ giúp em vượt qua các thách thức trong quá trình làm đồ án tốt nghiệp mà còn giúp em phát triển kỹ năng phân tích, tự giải quyết vấn đề và lập luận logic.

\end{document}